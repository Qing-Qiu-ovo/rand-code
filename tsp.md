# 浅谈TSP 商旅问题以及解法

作者：清小秋ovo

时间：2022.2.5

## 参考资料

1. https://blog.csdn.net/m0_37872090/article/details/80328140
2. http://t.csdn.cn/cL96v
3. http://t.csdn.cn/YplAm

## 问题描述

一位商人必须到 $N$ 座城市送货物，要求每座城市恰好访问一次，并最后返回出发城市。假设任意从一座城市到另一座城市的旅行费用都是整数值（若能通行），而旅行所需的全部费用是他旅行经过城市近邻之间费用的总和。请编程实现找到费用最低的旅行方案。
旅行商问题中，五座城市之间费用邻接矩阵 $C$ 表示，其中 $C_{i j}$ 表示第 $i$ 座城市与第 $j$ 座城市之间的费用，如果无路则为 `INF`。

此题的意思可以转化为： 令 $G=(V, E)$ 是一个带权重的有向图，顶点集$V=(v_0, v_1, ..., v_{n-1})$ 。从图中任一顶点 $v_i$ 出发，经图中所有顶点一次且只有一次，最后回到同一点的最短路径。

来看一组样例：

| 0 | 1 | 2 | 3 | 4 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| INF | 4 | INF | 9 | 8 |
| 4 | INF | 3 | 10 | 6 |
| INF | 3 | INF | 5 | 3 |
| 9 | 10 | 5 | INF | 21 |
|  8| 6 | 3 | 21 | INF |

这个就是典型的邻接矩阵。显然自己连接自己时是无路的。注意，图并不是一个完全图，有些节点之间也没有边。

## 解法 $1$ 暴力枚举

可以在 $N$ 个点中任选一个做为起点，依次枚举每条回路，最终算出最小值。

这种算法虽然直接，但是缺点在于时间复杂度过高，大概是 $O(n!)$ 。

如果图稍微大一点的话，将耗费大量的时间

## 解法 $2$ 状压 DP

### DP 问题的引入

DP (Dynamic Programing，动态规划) 是一种优化的搜索方法。主要用来求解最优解，采用了记忆化搜索。状压 DP 是 DP 的一种，主要采用了 二进制压缩到十进制的方式来表示状态，是一种简洁，快速的优化。

既然是 DP， 那么首先就需要找状态。

设 从顶点 $S$ 出发，那么 `dp[i][v]` 表示从 $s$ 出发，经过点 $i$，走一条经过点集合 $V$ 的最短回路。

那么接下来进入推导状态环节。

可以考虑进行分类讨论。

首先，对于 $V$ 是空集的情况来讲，那么就表示从 $s$ 直接回到 $i$ 了。所以此时数值应该就直接对应矩阵上边的价值，也就是 `dp[i][0]` $ =C_{iS}$。

其次，就是对于 $V$ 不为空集的情况来来讲，那么就是来求解最优子问题了。

可以推导出如下式子: `dp[i][v]`$= \min (dp[i][v], C_{ik}+dp[k][V-k])$。

那么我们最终的状态转移方程就呼之欲出了：

![](https://img-blog.csdnimg.cn/20190923192452307.png)


### 状压DP

我们用一个二进制数来存储每个集合的值。对于一个不为空的集合，每一个点只有两个状态：即 $0$ 或 $1$。前者表示不访问，后者表示访问。

看个具体例子：对于集合: {$1,2,3,4$}, 可以转化为 {$1,1,1,1$}，表示访问1，2，3，4城市。而这个{$1,1,1,1$}可以转化为一个二进制数: $1111_{2}$，在十进制下，这个数就是 $15$。

DP表格如下：

![DPchart](https://img-blog.csdnimg.cn/20190923200357348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTU5NjQx,size_16,color_FFFFFF,t_70)

如此我们就可以推导出一些有用的式子：

第 $y$ 个城市: `1<<(y-1)`。

如何才能取到某个状态的值呢？可以采用如下式子 ` (((x >> (i - 1) ) & 1) == 1`

而集合K的减法可以用异或来实现: `x = x ^ (1<<(i - 1))`。


那么我们就可以根据 DP 式子 以及位运算技巧来写出代码了：

（只给出核心代码）

```cpp
void TSP(){
    //初始化dp[i][0]
    for(int i = 0 ; i < N ;i++){
        dp[i][0] = g[i][0];
    }
    //求解dp[i][j],先跟新列在更新行
    for(int j = 1 ; j < M ;j++){
        for(int i = 0 ; i < N ;i++ ){
            dp[i][j] = INF;
            //如果集和j(或状态j)中包含结点i,则不符合条件退出
            if( ((j >> (i-1)) & 1) == 1){
                continue;
            }
            for(int k = 1 ; k < N ; k++){ //枚举集合j中的节点

                if( ((j >> (k-1)) & 1) == 0){
                    continue;
                } //如果集合中没有节点k，退出。
                if( dp[i][j] > g[i][k] + dp[k][j^(1<<(k-1))]){
                    dp[i][j] = g[i][k] + dp[k][j^(1<<(k-1))]; //使用异或去掉集合j中的节点k。
                }
            }
        }
    }
 
}
```


